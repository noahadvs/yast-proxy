/**
 * File:	modules/Proxy.ycp
 * Package:	Network configuration
 * Summary:	Proxy data
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 *
 * Configures FTP and HTTP proxies via sysconfig & SuSEconfig
 * and /root/.curlrc (for YOU)
 */

{

module "Proxy";
textdomain "proxy";

import "Summary";
import "Progress";
import "Mode";
import "Popup";

global boolean proposal_valid = false;
global boolean write_only = false;

/**
 * Data was modified?
 */
global boolean modified = false;

global boolean enabled = false;
global string http = "";
global string https = "";
global string ftp = "";
global string no = "";
global string user = "";
global string pass = "";

/**
 * Display popup at the end of the proxy configuration
 * @param modified true if proxy settings have been modified
 */
void ProxyFinishPopup(boolean modified) {
    if(!modified) return;

    /* Popup headline */
    string head = _("Proxy Configuration Successfully Saved");
    string text = _("It is recommended to relogin to make new proxy settings effective.");
    Popup::AnyMessage(head, text);
}

/**
 * Create comment for changed file
 * @param modul YaST2 module changing the file
 * @return comment
 * @example ChangedComment("lan") -> # Changed by YaST2 module lan 1.1.2000"
 */
string ChangedComment(string modul) {
    string ret = "\n# Changed by YaST2";
    if(modul != nil && modul != "") ret = ret + " module " + modul;
    map out = (map)SCR::Execute(.target.bash_output, "/bin/date '+%x'");
    string date = out["stdout"]:"";
    if(date != "") ret = ret + " " + date;
    return ret;
}

/**
 * Read settings
 * @return true if success
 */
global define boolean Read() {

    /* Read /etc/sysconfig/proxy */
    http = (string) SCR::Read(.sysconfig.proxy.HTTP_PROXY);
    if(http == nil) http = "";
    https = (string) SCR::Read(.sysconfig.proxy.HTTPS_PROXY);
    if(https == nil) https = "";
    ftp = (string) SCR::Read(.sysconfig.proxy.FTP_PROXY);
    if(ftp == nil) ftp = "";
    no = (string) SCR::Read(.sysconfig.proxy.NO_PROXY);
    if(no == nil) no = "";
    enabled = (string) SCR::Read(.sysconfig.proxy.PROXY_ENABLED) != "no";

    /* Read /root/.curlrc */
    if(SCR::Read(.target.size, "/root/.curlrc") > 0)
	user = (string) SCR::Read (add (.root.curlrc, "--proxy-user"));

    if(user == nil) user = "";

    if(issubstring(user, ":")) {
	pass = regexpsub(user, "^.*:(.*)$", "\\1");
	user = regexpsub(user, "^(.*):.*$", "\\1");
    }

    if(pass == nil) pass = "";
    if(user == nil) 
	user = "";
    else {
	if ( regexpmatch(user, "^.*\\\\.*$"))
	    user = regexpsub(user, "^(.*)\\\\(.*)$", "\\1\\2");
    }

    /* Read /root/.wgetrc */
    /* YOU uses curl(1)
    user = SCR::Read(.root.wgetrc.proxy_user);
    if(user == nil) user = "";
    pass = SCR::Read(.root.wgetrc.proxy_passwd);
    if(pass == nil) pass = "";
    */

    return true;
}

/**
 * Write routing settings and apply changes
 * @return true if success
 */
global define boolean Write() {

    y2milestone("Writing configuration");
    if(!modified) {
	y2milestone("No changes to proxy configuration -> nothing to write");
	return true;
    }

    list <string> steps = [
	_("Update proxy configuration"),
    ];

    string caption = _("Saving Proxy Configuration");
    // sleep for longer time, so that progress does not disappear right afterwards
    // but only when Progress is visible
    integer sl = (Progress::status() == true ? 500 : 0);

    Progress::New(caption, " ", size(steps), steps, [], "");

    Progress::NextStage();
    Progress::Title(_("Updating proxy configuration..."));

    /* Update /etc/sysconfig/proxy */
    SCR::Write(.sysconfig.proxy.PROXY_ENABLED, enabled?"yes":"no");
    SCR::Write(.sysconfig.proxy.HTTP_PROXY, http);
    SCR::Write(.sysconfig.proxy.HTTPS_PROXY, https);
    SCR::Write(.sysconfig.proxy.FTP_PROXY, ftp);
    SCR::Write(.sysconfig.proxy.NO_PROXY, no);
    SCR::Write(.sysconfig.proxy, nil);

    // proxy is used, write /root/.curlrc
    // bugzilla #305163
    if (enabled) {
	/* Update /root/.curlrc */
	string proxyuser = nil;
	if (user != "") {
	    //Escape backslash characters in .curlrc (#331038)
            user = mergestring (splitstring(user, "\\"), "\\\\");
	    proxyuser = user;
	    if (pass != "") proxyuser = user + ":" + pass;
	}

	// nil or real value
	SCR::Write (add (.root.curlrc, "--proxy-user"), proxyuser);

	// not 'nil', not empty
	// bugzilla #305163
	if (http != nil && size (http) > 0) {
	    SCR::Write (add (.root.curlrc, "--proxy"), http);
	} else {
	    SCR::Write (add (.root.curlrc, "--proxy"), nil);
	}

	// only written value can have a comment
	if (proxyuser != nil) {
	    SCR::Write (add (add (.root.curlrc, "--proxy-user"), "comment"), ChangedComment("proxy"));
	// only when set, can have a comment
	} else if (http != nil && size (http) > 0) {
	    SCR::Write (add (add (.root.curlrc, "--proxy"), "comment"), ChangedComment("proxy"));
	}
    // proxy is not used, remove proxy-related settings
    } else {
	SCR::Write (add (.root.curlrc, "--proxy-user"), nil);
	SCR::Write (add (.root.curlrc, "--proxy"), nil);
    }

    SCR::Write(.root.curlrc, nil);
    sleep(sl);
    Progress::NextStage();

    //user can't relogin in installation and update, do not show the msg then (bnc#486037, bnc#543469)
    if (Mode::normal())
	ProxyFinishPopup(true);

    /* Update /root/.wgetrc */
    /* YOU uses curl(1)
    SCR::Write(.root.wgetrc.proxy_user, user);
    SCR::Write(.root.wgetrc.proxy_passwd, pass);
    SCR::Write(.root.wgetrc, nil); */

    modified = false;

    return true;
}


/**
 * Get all settings from a map.
 * When called by <name>_auto (preparing autoinstallation data)
 * the map may be empty.
 * @param settings autoinstallation settings
 * @return true if success
 */
global define boolean Import(map settings) {
    enabled = settings["enabled"]:false;
    http = settings["http_proxy"]:"";
    https = settings["https_proxy"]:"";
    ftp = settings["ftp_proxy"]:"";
    no = settings["no_proxy"]:"localhost";
    user = settings["proxy_user"]:"";
    pass = settings["proxy_password"]:"";

    modified = true;
    return true;
}

/**
 * Runs tests of the HTTP and FTP proxy
 *
 * @param string http_proxy	such as "http://cache.example.com:3128"
 * @param string https_proxy	such as "http://cache.example.com:3128"
 * @param string ftp_proxy	such as "http://cache.example.com:3128"
 * @param string proxy_user	such as "proxy-username"
 * @param string proxy_password	such as "proxy-password"
 *
 * @return map <string, map <string, any> > with results of the test
 * @struct return = $[
 *	"HTTP" : $[
 *		"exit" : _exit_code,
 *		"stdout" : _stdout,
 *		"stderr" : _stderr,
 *	],
 *	"HTTPS" : $[
 *		"exit" : _exit_code,
 *		"stdout" : _stdout,
 *		"stderr" : _stderr,
 *	],
 *	"FTP" : $[
 *		"exit" : _exit_code,
 *		"stdout" : _stdout,
 *		"stderr" : _stderr,
 *	],
 * ]
 */
global define map <string, map <string, any> > RunTestProxy (string http_proxy, string https_proxy, string ftp_proxy, string proxy_user, string proxy_password) {
    // /usr/bin/curl --verbose
    // --proxy http://server_name:port_number
    // --proxy-user user:password
    // --url http://www.novell.com or ftp://ftp.novell.com | suggested for HTTP or FTP test
    // --url https://secure-www.novell.com --insecure
    map <string, map <string, any> > ret = $[];

    boolean test_http = ((http_proxy != "" && http_proxy != "http://") ? true:false);
    boolean test_https = ((https_proxy != "" && https_proxy != "http://") ? true:false);
    boolean test_ftp  = ((ftp_proxy  != "" && ftp_proxy  != "http://") ? true:false);

    http_proxy		= mergestring (splitstring(http_proxy, "\""), "\\\"");
    https_proxy		= mergestring (splitstring(https_proxy, "\""), "\\\"");
    ftp_proxy		= mergestring (splitstring(ftp_proxy, "\""), "\\\"");
    proxy_user		= mergestring (splitstring(proxy_user, "\""), "\\\"");
    //escape also '\' character - usernames such as domain\user are causing pain to .target.bash_output
    //and to curl - #256360
    proxy_user		= mergestring (splitstring(proxy_user, "\\"), "\\\\");
    proxy_password	= mergestring (splitstring(proxy_password, "\""), "\\\"");

    // enclose user:password into quotes, it may contain special characters (#338264)
    string user_pass = (proxy_user != "" ?
	" --proxy-user '" +  proxy_user + (proxy_password != "" ?
	    ":" + proxy_password
	    :
	    "") + "'"
	:
	"");

    // timeout for the connection
    integer timeout_sec = 90;
    // %1 = http or ftp proxy, %2 = user:password if any, %3 = URL
    string command = "curl --verbose --proxy %1 %2 --connect-timeout %3 --url %4";
    string http_command = sformat(command, http_proxy, user_pass, timeout_sec, "http://www.novell.com");
    // adding option --insecure to accept the certificate without asking
    string https_command = sformat(command, https_proxy, user_pass, timeout_sec, "https://secure-www.novell.com --insecure");
    string ftp_command  = sformat(command, ftp_proxy,  user_pass, timeout_sec, "ftp://ftp.novell.com");

    y2milestone("Running HTTP_PROXY test...");
    if (test_http) {
	y2milestone("Testing HTTP proxy %1", http_proxy);
	ret["HTTP"] = (map <string, any>) SCR::Execute(.target.bash_output, http_command);
    } else {
	y2milestone("Skipping HTTP Proxy test, no proxy used.");
	ret["HTTP"] = $["exit":0, "stderr":"", "stdout":"", "tested":false];
    }
    y2milestone("Done.");

    y2milestone("Running HTTPS_PROXY test...");
    if (test_https) {
	y2milestone("Testing HTTPS proxy %1", https_proxy);
	ret["HTTPS"] = (map <string, any>) SCR::Execute(.target.bash_output, https_command);
    } else {
	y2milestone("Skipping HTTPS Proxy test, no proxy used.");
	ret["HTTPS"] = $["exit":0, "stderr":"", "stdout":"", "tested":false];
    }
    y2milestone("Done.");

    y2milestone("Running FTP_PROXY test...");
    if (test_ftp) {
	y2milestone("Testing FTP proxy %1", ftp_proxy);
	ret["FTP"]  = (map <string, any>) SCR::Execute(.target.bash_output, ftp_command);
    } else {
	y2milestone("Skipping FTP Proxy test, no proxy used.");
	ret["FTP"] = $["exit":0, "stderr":"", "stdout":"", "tested":false];
    }
    y2milestone("Done.");

    return ret;
}

/**
 * Dump the Routing settings to a map, for autoinstallation use.
 * @return autoinstallation settings
 */
global define map Export() {
    map settings = $[
	"enabled"	: enabled,
	"http_proxy"	: http,
        "https_proxy"   : https,
	"ftp_proxy"	: ftp,
	"no_proxy"	: no,
	"proxy_user"	: user,
	"proxy_password": pass,
    ];
    return settings;
}

/**
 * Create proxy summary
 * @return summary text
 */
global define string Summary() {

    list<string> ret = [];

    /* Summary text */
    if(!enabled) ret = [ Summary::Device(_("Proxy is disabled."), "") ];

    else {

	/* Summary text */
	ret = [ Summary::Device(_("Proxy is enabled."), "" +
	/* Summary text */
	(http != "" ? sformat(_("HTTP Proxy: %1"), http) + "<br>" : "" ) +
        /* Summary text */
        (https != "" ? sformat(_("HTTPS Proxy: %1"), https) + "<br>" : "" ) +
	/* Summary text */
	(ftp != "" ? sformat(_("FTP Proxy: %1"), ftp) + "<br>" : "" ) +

	"" )];

	    /* Summary text * /
	    Summary::Device(sformat(_("No Proxy Domains: %1"), no) + "\n<br>" +
	    "<p>" + ( user == "" ?
		/* Summary text * /
		_("Proxy user name is not set.") :
		/* Summary text * /
		sformat(_("Proxy User Name: %1"), user)) +
	    "<br>" + ( pass == "" ?
		/* Summary text * /
		_("Proxy password is not set.") :
		/* Summary text * /
		_("Proxy password is set.")) ];
		*/
    }

    return Summary::DevicesList(ret);
}

/**
 * Function which returns if the settings were modified
 * @return boolean  settings were modified
 */
global define boolean GetModified () {
    return modified;
}
/**
 * Function sets internal variable, which indicates, that any
 * settings were modified, to "true"
 */
global define void SetModified () {
    modified = true;
}

/**
 * Function returns an environment usable for curl.  The proxy user/password
 * are read from /root/.curlrc.
 */
global define map <string, string> GetEnvironment ()
{
    if (!enabled)
	return $[];

    if (!modified)
	Read ();

    return $[
	     "http_proxy"	: http,
	     "HTTPS_PROXY"	: https,
	     "FTP_PROXY"	: ftp,
	     "NO_PROXY"		: no
    ];
}

/* EOF */
}
